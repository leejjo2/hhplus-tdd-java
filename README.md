**요구 사항**

- PATCH  `/point/{id}/charge` : 포인트를 충전한다.
- PATCH `/point/{id}/use` : 포인트를 사용한다.
- GET `/point/{id}` : 포인트를 조회한다.
- GET `/point/{id}/histories` : 포인트 내역을 조회한다.
- 잔고가 부족할 경우, 포인트 사용은 실패하여야 합니다.
- 동시에 여러 건의 포인트 충전, 이용 요청이 들어올 경우 순차적으로 처리되어야 합니다.


### `Default`

- `/point` 패키지 (디렉토리) 내에 `PointService` 기본 기능 작성
- `/database` 패키지의 구현체는 수정하지 않고, 이를 활용해 기능을 구현
- 각 기능에 대한 단위 테스트 작성

> 총 4가지 기본 기능 (포인트 조회, 포인트 충전/사용 내역 조회, 충전, 사용) 을 구현합니다.


### `Step 1`

- 포인트 충전, 사용에 대한 정책 추가 (잔고 부족, 최대 잔고 등)
- 동시에 여러 요청이 들어오더라도 순서대로 (혹은 한번에 하나의 요청씩만) 제어될 수 있도록 리팩토링
- 동시성 제어에 대한 통합 테스트 작성



### `Step 2`

- 동시성 제어 방식에 대한 분석 및 보고서 작성 ( **README.md** )

---


## 1. **동시성 문제 정의**
여러 사용자들이 동시에 포인트를 충전하거나 사용하는 시나리오에서는, 동일한 사용자에 대한 요청이 중복 처리되거나, 순서가 어긋나는 등의 문제가 발생할 수 있습니다. 이를 해결하기 위해서는 각 요청이 순차적으로 처리되고, 동일한 자원에 대한 여러 요청이 동시에 처리되지 않도록 제어해야 합니다.

### 발생 가능한 동시성 문제
- **Race Condition**: 여러 스레드가 동시에 동일한 데이터에 접근하여 예상치 못한 결과를 초래할 수 있음.
- **Deadlock**: 잘못된 락 사용으로 인해 시스템이 멈추는 문제.
- **Starvation**: 공정성이 보장되지 않을 때, 특정 스레드가 작업을 계속 기다리는 상황.

---

## 2. **사용한 동시성 제어 방법**
### 1. **`synchronized`**
`Synchronized`는 Java에서 **메서드** 또는 **블록**을 동기화하는 데 사용됩니다. 이를 통해 하나의 스레드만 특정 코드 블록에 접근하도록 보장하며, 데이터 무결성을 보장하는 방식입니다.

#### **특징**
- **단일 스레드 접근**: `synchronized`가 적용된 메서드나 블록은 한 번에 하나의 스레드만 접근할 수 있습니다. 다른 스레드는 해당 메서드가 실행 중일 때 블록되며, 실행이 완료되면 다음 스레드가 접근합니다.
- **경쟁 조건 해결**: 여러 스레드가 동시에 동일한 데이터를 수정할 때 발생하는 **경쟁 조건**을 방지할 수 있습니다.
- **세밀한 동기화**: 메서드 전체를 동기화할 수도 있고, 특정 블록만 동기화하여 필요한 부분에만 잠금을 적용할 수 있습니다.

#### **장점**
- **간단하고 직관적**: `synchronized`는 코드 레벨에서 적용하기 매우 쉽고 직관적입니다.
- **데이터 무결성 보장**: 동시성 문제를 해결하는 데 강력한 방법으로, 코드 실행의 안전성을 보장합니다.

#### **단점**
- **성능 저하**: 한 번에 하나의 스레드만 접근 가능하므로, 스레드가 많을 경우 성능 저하가 발생할 수 있습니다. 특히, **경합이 잦은 환경**에서는 스레드 대기 시간이 길어집니다.
- **전체 락**: 특정 객체 또는 메서드에 대해 전체적인 락을 걸어야 하기 때문에, 불필요하게 넓은 범위에 대한 락이 걸릴 수 있습니다.

```java
public synchronized void add(int value) {
    balance += value;
}
```



### 2. **`ConcurrentHashMap`**
`ConcurrentHashMap`은 `HashMap`의 스레드 안전한 버전으로, **비블로킹 방식**으로 동시성을 제어합니다. 내부적으로는 **세분화된 락**(Segmented Lock)을 사용하여, 여러 스레드가 동시 접근할 수 있도록 설계되었습니다.

#### **특징**
- **세분화된 락**: `ConcurrentHashMap`은 내부적으로 데이터를 여러 개의 세그먼트로 나누고, 각 세그먼트에 대해 개별적으로 락을 걸어줍니다. 덕분에 다수의 스레드가 **동시에 다른 세그먼트에 접근**할 수 있습니다.
- **높은 성능**: 다수의 스레드가 동시에 접근해도 효율적인 처리가 가능하여 **락 경합**이 적습니다.
- **락-프리 읽기**: `get()` 연산은 **락을 사용하지 않으며** 여러 스레드가 자유롭게 읽을 수 있습니다. 다만 `put()`과 같은 쓰기 연산은 락을 사용합니다.

#### **장점**
- **높은 성능**: `synchronized`와 달리 **동시성을 더 효율적으로 처리**할 수 있으며, 다수의 스레드가 동시에 읽기/쓰기 연산을 수행할 수 있습니다.
- **세분화된 락으로 락 경합 최소화**: 데이터 접근 시 락을 세분화하여, 여러 스레드가 동시에 다른 데이터를 수정할 수 있으므로 성능이 뛰어납니다.

#### **단점**
- **구현 복잡성**: 내부적으로 복잡한 락 관리가 필요하며, 단순한 `synchronized`보다 코드의 이해와 활용이 어렵습니다.
- **고립된 문제 처리 불가**: `ConcurrentHashMap`은 주로 **다수의 쓰레드가 여러 키를 동시에 읽고 쓰는** 상황에서 뛰어나지만, 개별 키에 대해 세밀하게 처리하는 것은 어렵습니다. 특정한 키에 대해 순차적 처리가 요구된다면 별도의 동기화 기법이 필요할 수 있습니다.

```java
private ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();

public void updateBalance(String userId, int value) {
    map.put(userId, map.getOrDefault(userId, 0) + value);
}
```

### 3. **`ReentrantLock`**
- `ReentrantLock`은 락을 명시적으로 관리할 수 있게 해주는 클래스로, 스레드가 특정 코드 블록을 독점적으로 실행하도록 보장합니다.
- 공정성 매개변수(Fairness Parameter)를 설정할 수 있으며, 공정성을 활성화하면 락이 사용된 순서대로 스레드가 락을 획득합니다.

### 4. **`ExecutorService`**
- 작업 스레드를 관리하는 프레임워크로, 스레드 풀을 통해 여러 작업을 병렬적으로 처리할 수 있습니다.
- `ExecutorService`를 사용해 스레드를 재사용하고, 과도한 스레드 생성으로 인한 성능 저하를 방지합니다.
- 단일 스레드 풀을 사용할 경우 순차적인 작업 처리가 가능하며, 동시 요청이 있더라도 큐에 쌓여 순서대로 처리됩니다.

--- 

## 3. **동시성 제어의 구현**
### 3.1 **포인트 충전/사용**
- 각 유저에 대해 `ConcurrentHashMap`을 통해 유저별로 `ReentrantLock`을 관리합니다. 유저가 요청을 할 때마다 해당 유저의 락을 획득한 후 작업을 처리합니다.
- 포인트 충전 또는 사용 중에는 락을 해제하지 않기 때문에, 해당 유저에 대한 작업이 완료될 때까지 다른 요청이 처리되지 않습니다.

```java
private final ConcurrentHashMap<Long, ReentrantLock> userLocks = new ConcurrentHashMap<>();

public void chargeUserPoint(Long userId, int points) {
    ReentrantLock lock = userLocks.computeIfAbsent(userId, k -> new ReentrantLock());
    lock.lock();
    try {
        // 포인트 충전 로직
    } finally {
        lock.unlock();
    }
}
```

### 3.2 **순차적 처리**
- `ExecutorService`와 `BlockingQueue`를 사용해 각 유저별로 작업이 큐에 쌓이도록 하고, 단일 스레드에서 순차적으로 처리할 수 있습니다.
- 큐에 작업을 추가하는 방식이므로, 특정 유저에 대한 충전/사용 작업이 동시에 들어와도 순차적으로 처리됩니다.

```java
private final ExecutorService executorService = Executors.newSingleThreadExecutor();

public void processQueueWithoutLock(BlockingQueue<Runnable> queue) {
    executorService.submit(() -> {
        while (!queue.isEmpty()) {
            Runnable task = queue.poll();
            if (task != null) {
                task.run();
            }
        }
    });
}
```

---

## 4. **테스트 시 고려 사항**
###  **`CompletableFuture`와 `CountDownLatch`를 이용한 비동기 테스트**
- 여러 요청이 동시에 발생하는 상황을 테스트하기 위해 `CompletableFuture`와 `CountDownLatch`를 사용합니다. 이를 통해 요청들이 동시에 실행되는 상황을 시뮬레이션하고, 예상한 대로 순차적 처리가 이루어지는지 검증할 수 있습니다.
- **문제점**: `ExecutorService`의 미세한 시간차로 인해 때때로 동시성 문제가 발생할 수 있습니다. 이 경우 테스트 실패는 스레드 관리의 문제로, 더 정교한 스레드 풀 설정이 필요할 수 있습니다.

---
## 5. **공정성(Fairness)에 대한 분석**
`ReentrantLock`의 공정성 옵션을 사용하면, 락을 먼저 요청한 스레드가 먼저 락을 획득하도록 보장할 수 있습니다. 하지만 공정성을 활성화하면 성능에 약간의 영향을 미칠 수 있으므로, 실제로 공정성이 필요한 경우에만 사용해야 합니다. 공정성을 비활성화하면 성능은 좋아지지만, 특정 스레드가 락을 계속 점유하는 **Starvation** 문제가 발생할 수 있습니다.

### **공정성 적용 방법**
```java
ReentrantLock lock = new ReentrantLock(true); // 공정성 보장
```
---
## 6. **결론 및 개선 방향**
- 현재 `ConcurrentHashMap`과 `ReentrantLock`을 사용한 동시성 제어는 성능과 동시성 문제 해결에 효과적입니다.
- 하지만 공정성 문제와 성능의 균형을 맞추는 것이 중요한 과제이며, 공정성을 엄격히 요구하는 시스템에서는 `ReentrantLock`의 공정성 매개변수를 적극적으로 사용하는 것을 고려할 수 있습니다.
- 추후 성능 테스트와 더불어 실제 부하 시나리오에서의 동작을 면밀히 분석하여, 성능과 안정성을 최적화하는 것이 필요합니다.

---
## 7. **이외 시도한 방법**
### **단일 스레드 `ExecutorService`를 활용한 동시성 제어**

`ConcurrentHashMap`과 `ReentrantLock`을 사용하는 대신, **단일 스레드**로 동작하는 `ExecutorService`를 활용하여 동시성을 제어하는 방식도 함께 사용했습니다. 이 방식은 **순차적 처리**를 보장하기 위해 모든 요청을 단일 스레드에서 처리함으로써, 특정 유저에 대한 요청이 한 번에 하나씩 처리되도록 만듭니다.

#### **1. 동작 원리**
- 단일 스레드로 동작하는 `ExecutorService`를 사용하여, 유저에 대한 작업을 처리하는 방식입니다. 이 방식을 사용하면, 하나의 스레드가 순차적으로 큐에 있는 작업을 처리하기 때문에 `ReentrantLock`을 사용하지 않아도 동시성 문제가 해결됩니다.
- 작업 요청은 큐에 쌓이고, `ExecutorService`는 순차적으로 각 작업을 실행하여 **충돌 없이 순차적 처리**를 보장합니다.

```java
private final ExecutorService executorService = Executors.newSingleThreadExecutor();

public void executeTask(Runnable task) {
    executorService.submit(task);
}
```

#### **2. 장점**
- **동기화 부담 감소**: `ReentrantLock`과 같은 복잡한 락을 관리할 필요 없이, 단일 스레드에서 모든 작업이 처리되므로 스레드 간 경쟁이 발생하지 않습니다.
- **순차 처리 보장**: 각 작업이 큐에 쌓인 순서대로 처리되므로, 동시성 문제 없이 안정적인 작업 순서를 보장할 수 있습니다.
- **코드 간결성**: 락을 명시적으로 사용할 필요가 없기 때문에 코드가 간결하고 유지보수가 쉬워집니다.

#### **3. 단점 및 한계**
- **성능 이슈**: 단일 스레드에서 모든 작업을 처리하기 때문에, 작업량이 많아지면 처리 속도가 느려질 수 있습니다. 특히, 다수의 사용자가 동시에 요청을 보낼 때 대기 시간이 길어질 가능성이 있습니다.
- **확장성 문제**: 단일 스레드는 여러 요청을 처리하는 데 있어서 병목 현상을 초래할 수 있으며, 멀티스레드 환경에서의 성능 이점을 활용할 수 없습니다.
- **비동기적 요청 처리**: 비동기 요청을 효율적으로 처리하려면 추가적인 큐 관리가 필요할 수 있습니다. 특히 비동기적으로 긴 시간이 필요한 작업이 있을 때 병렬 처리가 제한되므로 성능이 저하될 수 있습니다.

#### **4. 적용 사례**
단일 스레드 `ExecutorService`는 **단일 유저의 요청을 순차적으로 처리해야 하는 경우** 적합합니다. 이 방식은 락 관리의 부담을 줄이고, 단일 유저의 충전/사용 요청이 동시 다발적으로 들어올 때 **순서를 보장**하는 데 효과적입니다. 예를 들어, 아래와 같은 상황에서 유용할 수 있습니다.
- 사용자 포인트 충전/사용 시, 요청이 중복되거나 순서가 꼬이는 상황을 방지할 때.
- 단일 작업에 대한 동시성 요구사항이 높지 않고, 순차적 처리만 보장되면 되는 경우.

#### **5. 결론**
단일 스레드 `ExecutorService`를 활용한 동시성 제어는 간단하고 직관적인 방법으로, 특정 상황에서 **락 없이도 동시성 문제를 해결**할 수 있습니다. 그러나 확장성과 성능 면에서 제약이 있을 수 있기 때문에, **작업량이 많지 않거나 유저별로 확실한 순차 처리가 필요한 상황**에서 사용하면 적합합니다.

